pragma Singleton

import Quickshell
import Quickshell.Io
import QtQuick

Singleton {
    id: root

    readonly property list<AccessPoint> networks: []
    readonly property AccessPoint active: networks.find(n => n.active) ?? null
    property bool wifiEnabled: true
    readonly property bool scanning: rescanProc.running

    // Internet connectivity properties
    property bool internetConnected: false
    property string publicIpAddress: ""
    property string dnsServer: ""
    property int pingLatency: 0

    // VPN properties
    property bool vpnConnected: false
    property string vpnConnectionName: ""
    property string vpnType: ""
    property string vpnServerAddress: ""

    // Mullvad-specific properties
    property bool mullvadConnected: false
    property string mullvadLocation: ""
    property string mullvadNodeName: ""
    property string mullvadServerType: ""

    // Ethernet properties (now supports multiple interfaces)
    property bool ethernetConnected: false
    property var ethernetConnections: [] // Array of ethernet connection objects
    property var knownEthernetConnections: ({}) // Track all ethernet connections we've seen

    reloadableId: "network"

    function enableWifi(enabled: bool): void {
        const cmd = enabled ? "on" : "off";
        enableWifiProc.exec(["nmcli", "radio", "wifi", cmd]);
    }

    function toggleWifi(): void {
        const cmd = wifiEnabled ? "off" : "on";
        enableWifiProc.exec(["nmcli", "radio", "wifi", cmd]);
    }

    function rescanWifi(): void {
        rescanProc.running = true;
    }

    function connectToNetwork(ssid: string, password: string): void {
        // TODO: Implement password
        connectProc.exec(["nmcli", "conn", "up", ssid]);
    }

    function disconnectFromNetwork(): void {
        if (active) {
            disconnectProc.exec(["nmcli", "connection", "down", active.ssid]);
        }
    }

    function getWifiStatus(): void {
        wifiStatusProc.running = true;
    }

    function toggleVpn(enable: bool): void {
        if (enable) {
            // Try to connect to the most recent VPN connection
            vpnToggleProc.exec(["nmcli", "connection", "up", "--ask"]);
        } else {
            // Disconnect current VPN
            if (vpnConnected && vpnConnectionName) {
                vpnToggleProc.exec(["nmcli", "connection", "down", vpnConnectionName]);
            }
        }
    }

    function toggleEthernet(connectionName: string, enable: bool): void {
        console.log("=== TOGGLE ETHERNET DEBUG ===");
        console.log("Connection Name:", connectionName);
        console.log("Enable:", enable);
        console.log("==============================");

        if (enable) {
            console.log("Executing: nmcli connection up '" + connectionName + "'");
            connectProc.exec(["nmcli", "connection", "up", connectionName]);
        } else {
            // Find the device for this connection
            const device = findDeviceForConnection(connectionName);
            if (device) {
                console.log("Executing: nmcli device disconnect '" + device + "'");
                disconnectProc.exec(["nmcli", "device", "disconnect", device]);
            } else {
                console.log("Device not found for connection:", connectionName);
            }
        }
    }

    function findDeviceForConnection(connectionName: string): string {
        // Find the device associated with this connection name
        for (const conn of ethernetConnections) {
            if (conn.connectionName === connectionName) {
                console.log("Found device for connection", connectionName, ":", conn.device);
                return conn.device;
            }
        }
        return "";
    }

    Process {
        running: true
        command: ["nmcli", "m"]
        stdout: SplitParser {
            onRead: getNetworks.running = true
        }
    }

    Process {
        id: wifiStatusProc

        running: true
        command: ["nmcli", "radio", "wifi"]
        environment: ({
                LANG: "C.UTF-8",
                LC_ALL: "C.UTF-8"
            })
        stdout: StdioCollector {
            onStreamFinished: {
                root.wifiEnabled = text.trim() === "enabled";
            }
        }
    }

    Process {
        id: enableWifiProc

        onExited: {
            root.getWifiStatus();
            getNetworks.running = true;
        }
    }

    Process {
        id: rescanProc

        command: ["nmcli", "dev", "wifi", "list", "--rescan", "yes"]
        onExited: {
            getNetworks.running = true;
        }
    }

    Process {
        id: connectProc

        stdout: SplitParser {
            onRead: getNetworks.running = true
        }
        stderr: StdioCollector {
            onStreamFinished: console.warn("Network connection error:", text)
        }
    }

    Process {
        id: disconnectProc

        stdout: SplitParser {
            onRead: {
                console.log("Disconnect stdout:", data);
                getNetworks.running = true;
            }
        }
        stderr: StdioCollector {
            onStreamFinished: {
                console.warn("Network disconnection error:", text);
                console.warn("Full stderr output:", text);
            }
        }
    }

    Process {
        id: vpnToggleProc

        stdout: StdioCollector {
            onStreamFinished: {
                // Refresh VPN status after toggle
                vpnCheckProc.running = true;
            }
        }
        stderr: StdioCollector {
            onStreamFinished: console.warn("VPN toggle error:", text)
        }
    }

    Process {
        id: getNetworks

        running: true
        command: ["nmcli", "-g", "ACTIVE,SIGNAL,FREQ,SSID,BSSID,SECURITY", "d", "w"]
        environment: ({
                LANG: "C.UTF-8",
                LC_ALL: "C.UTF-8"
            })
        stdout: StdioCollector {
            onStreamFinished: {
                const PLACEHOLDER = "STRINGWHICHHOPEFULLYWONTBEUSED";
                const rep = new RegExp("\\\\:", "g");
                const rep2 = new RegExp(PLACEHOLDER, "g");

                const allNetworks = text.trim().split("\n").map(n => {
                    const net = n.replace(rep, PLACEHOLDER).split(":");
                    return {
                        active: net[0] === "yes",
                        strength: parseInt(net[1]),
                        frequency: parseInt(net[2]),
                        ssid: net[3],
                        bssid: net[4]?.replace(rep2, ":") ?? "",
                        security: net[5] || ""
                    };
                }).filter(n => n.ssid && n.ssid.length > 0);

                // Group networks by SSID and prioritize connected ones
                const networkMap = new Map();
                for (const network of allNetworks) {
                    const existing = networkMap.get(network.ssid);
                    if (!existing) {
                        networkMap.set(network.ssid, network);
                    } else {
                        // Prioritize active/connected networks
                        if (network.active && !existing.active) {
                            networkMap.set(network.ssid, network);
                        } else if (!network.active && !existing.active) {
                            // If both are inactive, keep the one with better signal
                            if (network.strength > existing.strength) {
                                networkMap.set(network.ssid, network);
                            }
                        }
                        // If existing is active and new is not, keep existing
                    }
                }

                const networks = Array.from(networkMap.values());

                const rNetworks = root.networks;

                const destroyed = rNetworks.filter(rn => !networks.find(n => n.frequency === rn.frequency && n.ssid === rn.ssid && n.bssid === rn.bssid));
                for (const network of destroyed)
                    rNetworks.splice(rNetworks.indexOf(network), 1).forEach(n => n.destroy());

                for (const network of networks) {
                    const match = rNetworks.find(n => n.frequency === network.frequency && n.ssid === network.ssid && n.bssid === network.bssid);
                    if (match) {
                        match.lastIpcObject = network;
                    } else {
                        rNetworks.push(apComp.createObject(root, {
                            lastIpcObject: network
                        }));
                    }
                }
            }
        }
    }

    // Ethernet detection process
    Process {
        id: ethernetProc

        running: true
        command: ["nmcli", "device", "status"]
        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                const lines = text.trim().split("\n");
                let ethernetConnections = [];

                console.log("=== NETWORK SERVICE DEBUG ===");
                console.log("Raw nmcli output:", text);
                console.log("Lines:", lines);

                // Skip header line and parse device status
                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split(/\s+/);

                    if (parts.length >= 4) {
                        const device = parts[0];
                        const type = parts[1];
                        const state = parts[2];
                        const connection = parts.slice(3).join(" ");

                        console.log(`Device: ${device}, Type: ${type}, State: ${state}, Connection: ${connection}`);

                        // Track ethernet devices (both connected and disconnected)
                        if (type === "ethernet") {
                            if (state === "connected" && connection !== "--") {
                                // Connected ethernet interface
                                console.log(`Adding ethernet connection: ${connection} on ${device} (${state})`);
                                const connObj = {
                                    connectionName: connection.trim(),
                                    device: device,
                                    ipAddress: "",
                                    macAddress: "",
                                    connected: true
                                };
                                ethernetConnections.push(connObj);
                                // Remember this connection
                                root.knownEthernetConnections[device] = connection.trim();
                            } else if (state === "disconnected" && root.knownEthernetConnections[device]) {
                                // Disconnected ethernet interface that we've seen before
                                const knownConnectionName = root.knownEthernetConnections[device];
                                console.log(`Adding disconnected ethernet connection: ${knownConnectionName} on ${device} (${state})`);
                                ethernetConnections.push({
                                    connectionName: knownConnectionName,
                                    device: device,
                                    ipAddress: null, // null indicates disconnected
                                    macAddress: null,
                                    connected: false
                                });
                            }
                        }
                    }
                }

                root.ethernetConnected = ethernetConnections.length > 0;
                // Force property change notification by creating a new array
                root.ethernetConnections = [...ethernetConnections];

                // Get details for each connected ethernet interface
                if (ethernetConnections.length > 0) {
                    ethernetDetailsProc.currentIndex = 0;
                    ethernetDetailsProc.command = ["nmcli", "-g", "IP4.ADDRESS,GENERAL.HWADDR", "d", "show", ethernetConnections[0].device];
                    ethernetDetailsProc.running = true;
                }
            }
        }
    }

    // Get ethernet IP and MAC address for each interface
    Process {
        id: ethernetDetailsProc

        property int currentIndex: 0

        environment: ({
            "LC_ALL": "C"
        })

        onStarted: {
            // Reset index when starting fresh
            currentIndex = 0;
        }

        stdout: StdioCollector {
            onStreamFinished: {
                const lines = text.trim().split("\n");
                let ipAddress = "";
                let macAddress = "";

                if (lines.length >= 1 && lines[0]) {
                    ipAddress = lines[0].split("/")[0]; // Remove CIDR notation
                }
                if (lines.length >= 2 && lines[1]) {
                    // Clean up MAC address by removing escape characters
                    macAddress = lines[1].replace(/\\:/g, ":");
                }

                // Update the current ethernet connection
                let connections = [...root.ethernetConnections];

                if (ethernetDetailsProc.currentIndex < connections.length) {
                    connections[ethernetDetailsProc.currentIndex].ipAddress = ipAddress;
                    connections[ethernetDetailsProc.currentIndex].macAddress = macAddress;
                    // Force property change notification by creating a new array
                    root.ethernetConnections = [...connections];

                    // Process next connection if available
                    ethernetDetailsProc.currentIndex++;
                    if (ethernetDetailsProc.currentIndex < connections.length) {
                        ethernetDetailsProc.command = ["nmcli", "-g", "IP4.ADDRESS,GENERAL.HWADDR", "d", "show", connections[ethernetDetailsProc.currentIndex].device];
                        ethernetDetailsProc.running = true;
                    }
                }
            }
        }
    }

    // Internet connectivity check
    Process {
        id: internetCheckProc

        running: true
        command: ["ping", "-c", "1", "-W", "3", "8.8.8.8"]
        environment: ({
            "LC_ALL": "C"
        })

        property string pingOutput: ""

        stdout: StdioCollector {
            onStreamFinished: {
                internetCheckProc.pingOutput = text;
            }
        }

        onExited: {
            root.internetConnected = exitCode === 0;

            // Extract ping time if successful
            if (exitCode === 0 && pingOutput) {
                const timeMatch = pingOutput.match(/time=(\d+(?:\.\d+)?)/);
                if (timeMatch) {
                    root.pingLatency = Math.round(parseFloat(timeMatch[1]));
                }
            }

            // Get public IP and DNS info if connected
            if (root.internetConnected) {
                publicIpProc.running = true;
                dnsInfoProc.running = true;
            }
        }
    }

    // Check internet connectivity every 30 seconds
    Timer {
        interval: 30000
        running: true
        repeat: true
        onTriggered: internetCheckProc.running = true
    }

    // Get public IP address
    Process {
        id: publicIpProc

        command: ["curl", "-s", "--max-time", "5", "https://ipinfo.io/ip"]
        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                if (text.trim()) {
                    root.publicIpAddress = text.trim();
                }
            }
        }
    }

    // Get DNS server info
    Process {
        id: dnsInfoProc

        command: ["nmcli", "-g", "IP4.DNS", "d", "show"]
        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                const lines = text.trim().split("\n");
                if (lines.length > 0 && lines[0]) {
                    root.dnsServer = lines[0];
                }
            }
        }
    }

    // VPN connection detection
    Process {
        id: vpnCheckProc

        running: true
        command: ["nmcli", "-g", "NAME,TYPE,DEVICE", "c", "show", "--active"]
        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                const lines = text.trim().split("\n");
                let vpnFound = false;
                let connectionName = "";
                let vpnType = "";

                for (const line of lines) {
                    if (line) {
                        const parts = line.split(":");
                        if (parts.length >= 2) {
                            const name = parts[0];
                            const type = parts[1];
                            const device = parts[2] || "";

                            // Check for VPN connection types
                            if (type.includes("vpn") || type.includes("wireguard") ||
                                type.includes("openvpn") || type.includes("pptp") ||
                                type.includes("l2tp") || device.includes("tun") ||
                                device.includes("wg")) {
                                vpnFound = true;
                                connectionName = name;
                                vpnType = type;
                                break;
                            }
                        }
                    }
                }

                root.vpnConnected = vpnFound;
                root.vpnConnectionName = connectionName;
                root.vpnType = vpnType;

                // Get VPN server details if connected
                if (vpnFound && connectionName) {
                    vpnDetailsProc.command = ["nmcli", "-g", "vpn.data", "c", "show", connectionName];
                    vpnDetailsProc.running = true;
                }
            }
        }
    }

    // Check ethernet connections every 10 seconds
    Timer {
        interval: 10000
        running: true
        repeat: true
        onTriggered: ethernetProc.running = true
    }

    // Check VPN status every 15 seconds
    Timer {
        interval: 15000
        running: true
        repeat: true
        onTriggered: vpnCheckProc.running = true
    }

    // Get VPN server details
    Process {
        id: vpnDetailsProc

        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                // Extract server address from VPN data
                const serverMatch = text.match(/remote\s*=\s*([^,\n]+)/);
                if (serverMatch) {
                    root.vpnServerAddress = serverMatch[1].trim();
                } else {
                    // Try alternative patterns for different VPN types
                    const altMatch = text.match(/gateway\s*=\s*([^,\n]+)/);
                    if (altMatch) {
                        root.vpnServerAddress = altMatch[1].trim();
                    }
                }
            }
        }
    }

    // Mullvad connection info (only check when VPN is connected)
    Process {
        id: mullvadInfoProc

        command: ["curl", "-s", "--max-time", "5", "https://am.i.mullvad.net/json"]
        environment: ({
            "LC_ALL": "C"
        })

        stdout: StdioCollector {
            onStreamFinished: {
                try {
                    const data = JSON.parse(text);

                    // Check if we're connected through Mullvad
                    if (data.mullvad_exit_ip === true) {
                        root.mullvadConnected = true;

                        // Set location (city, country)
                        if (data.city && data.country) {
                            root.mullvadLocation = `${data.city}, ${data.country}`;
                        }

                        // Set node name (hostname)
                        if (data.mullvad_exit_ip_hostname) {
                            root.mullvadNodeName = data.mullvad_exit_ip_hostname;
                        }

                        // Set server type
                        if (data.mullvad_server_type) {
                            root.mullvadServerType = data.mullvad_server_type;
                        }
                    } else {
                        root.mullvadConnected = false;
                        root.mullvadLocation = "";
                        root.mullvadNodeName = "";
                        root.mullvadServerType = "";
                    }
                } catch (e) {
                    // If JSON parsing fails or API is unavailable, reset Mullvad info
                    root.mullvadConnected = false;
                    root.mullvadLocation = "";
                    root.mullvadNodeName = "";
                    root.mullvadServerType = "";
                }
            }
        }
    }

    // Check Mullvad info when VPN status changes or every 30 seconds
    Timer {
        interval: 30000
        running: root.vpnConnected
        repeat: true
        onTriggered: mullvadInfoProc.running = true
    }

    // Also trigger Mullvad check when VPN connects
    Connections {
        target: root
        function onVpnConnectedChanged() {
            if (root.vpnConnected) {
                mullvadInfoProc.running = true;
            }
        }
    }

    component AccessPoint: QtObject {
        required property var lastIpcObject
        readonly property string ssid: lastIpcObject.ssid
        readonly property string bssid: lastIpcObject.bssid
        readonly property int strength: lastIpcObject.strength
        readonly property int frequency: lastIpcObject.frequency
        readonly property bool active: lastIpcObject.active
        readonly property string security: lastIpcObject.security
        readonly property bool isSecure: security.length > 0
    }

    Component {
        id: apComp

        AccessPoint {}
    }
}
